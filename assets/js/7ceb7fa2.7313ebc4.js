"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6678],{717:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-04-vla/week-11/ch18-joint-control","title":"Joint-Level Control","description":"Learning Objectives","source":"@site/docs/module-04-vla/week-11/ch18-joint-control.md","sourceDirName":"module-04-vla/week-11","slug":"/module-04-vla/week-11/ch18-joint-control","permalink":"/AI_COURSE_book/docs/module-04-vla/week-11/ch18-joint-control","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-04-vla/week-11/ch18-joint-control.md","tags":[],"version":"current","sidebarPosition":19,"frontMatter":{"id":"ch18-joint-control","title":"Joint-Level Control","sidebar_label":"Joint-Level Control","sidebar_position":19},"sidebar":"textbookSidebar","previous":{"title":"Humanoid Robot Modeling","permalink":"/AI_COURSE_book/docs/module-04-vla/week-11/ch17-humanoid-urdf"},"next":{"title":"Robotic Grasping","permalink":"/AI_COURSE_book/docs/module-04-vla/week-12/ch19-grasping"}}');var s=i(4848),t=i(8453);const r={id:"ch18-joint-control",title:"Joint-Level Control",sidebar_label:"Joint-Level Control",sidebar_position:19},l="Joint-Level Control",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"PID Control for Joint Tracking",id:"pid-control-for-joint-tracking",level:2},{value:"Implementing a PID Controller",id:"implementing-a-pid-controller",level:3},{value:"Tuning PID Gains",id:"tuning-pid-gains",level:3},{value:"MoveIt Integration for Motion Planning",id:"moveit-integration-for-motion-planning",level:2},{value:"Planning Groups",id:"planning-groups",level:3},{value:"Inverse Kinematics Solvers",id:"inverse-kinematics-solvers",level:3},{value:"Planning and Executing Trajectories",id:"planning-and-executing-trajectories",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:2},{value:"Task-Space vs Joint-Space Control",id:"task-space-vs-joint-space-control",level:3},{value:"Coordinated Arm + Torso Motion",id:"coordinated-arm--torso-motion",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:2},{value:"Issue 1: Joint Limit Violations",id:"issue-1-joint-limit-violations",level:3},{value:"Issue 2: Self-Collision",id:"issue-2-self-collision",level:3},{value:"Issue 3: Kinematic Singularities",id:"issue-3-kinematic-singularities",level:3},{value:"Issue 4: Oscillations and Instability",id:"issue-4-oscillations-and-instability",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2},{value:"Hands-On Exercises",id:"hands-on-exercises",level:2},{value:"Exercise 1: PID Tuning",id:"exercise-1-pid-tuning",level:3},{value:"Exercise 2: MoveIt Motion Planning",id:"exercise-2-moveit-motion-planning",level:3},{value:"Exercise 3: Whole-Body Waving",id:"exercise-3-whole-body-waving",level:3},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"joint-level-control",children:"Joint-Level Control"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Implement PID controllers for high-DOF humanoid joint tracking"}),"\n",(0,s.jsx)(e.li,{children:"Use MoveIt for motion planning and inverse kinematics"}),"\n",(0,s.jsx)(e.li,{children:"Coordinate whole-body motions with balance constraints"}),"\n",(0,s.jsx)(e.li,{children:"Handle common control issues (limits, collisions, singularities)"}),"\n",(0,s.jsx)(e.li,{children:"Tune control gains for stable, responsive humanoid behavior"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(e.p,{children:["Controlling humanoid robots presents unique challenges due to their ",(0,s.jsx)(e.strong,{children:"high degrees of freedom"})," (20-40 joints for full-body humanoids) and complex kinematic chains. Unlike mobile robots with 2-3 DOF or industrial arms with 6-7 DOF, humanoids require coordinated control across multiple limbs (arms, legs, torso, head) while maintaining balance and avoiding self-collision."]}),"\n",(0,s.jsx)(e.p,{children:"Humanoid joints come in two primary types:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Revolute joints"}),": Rotational (e.g., shoulder pitch/roll/yaw, knee)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Prismatic joints"}),": Linear (rare in humanoids, used in telescoping mechanisms)"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Each joint can be controlled in different modes:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Position control"}),": Command target joint angle (most common for humanoids)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Velocity control"}),": Command target joint velocity (useful for compliant motions)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Torque control"}),": Command target joint torque (advanced, requires good dynamics models)"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"In this chapter, we'll explore PID control for joint-level tracking, integrate MoveIt for high-level motion planning, implement whole-body coordination, and handle common pitfalls in humanoid control."}),"\n",(0,s.jsx)(e.h2,{id:"pid-control-for-joint-tracking",children:"PID Control for Joint Tracking"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"PID (Proportional-Integral-Derivative)"})," control is the foundation of joint-level tracking. Given a target joint position \u03b8_desired and current joint position \u03b8_actual, a PID controller computes the control command u:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"u(t) = K_p * e(t) + K_i * \u222be(t)dt + K_d * de/dt"})}),"\n",(0,s.jsx)(e.p,{children:"where:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"e(t) = \u03b8_desired - \u03b8_actual"})," (position error)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"K_p"}),": Proportional gain (immediate response to error)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"K_i"}),": Integral gain (eliminates steady-state error)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"K_d"}),": Derivative gain (dampens oscillations)"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"implementing-a-pid-controller",children:"Implementing a PID Controller"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass HumanoidPIDController(Node):\n    """PID controller for humanoid joint tracking"""\n\n    def __init__(self):\n        super().__init__(\'humanoid_pid_controller\')\n\n        # PID gains (per joint, tuned experimentally)\n        self.num_joints = 20\n        self.kp = np.array([100.0] * self.num_joints)  # Proportional\n        self.ki = np.array([0.1] * self.num_joints)    # Integral\n        self.kd = np.array([10.0] * self.num_joints)   # Derivative\n\n        # State variables\n        self.target_positions = np.zeros(self.num_joints)\n        self.current_positions = np.zeros(self.num_joints)\n        self.current_velocities = np.zeros(self.num_joints)\n        self.error_integral = np.zeros(self.num_joints)\n        self.prev_error = np.zeros(self.num_joints)\n\n        self.dt = 0.01  # 100 Hz control loop\n\n        # ROS interfaces\n        self.joint_state_sub = self.create_subscription(\n            JointState, \'/joint_states\', self.joint_state_callback, 10\n        )\n        self.target_sub = self.create_subscription(\n            Float64MultiArray, \'/joint_targets\', self.target_callback, 10\n        )\n        self.cmd_pub = self.create_publisher(\n            Float64MultiArray, \'/joint_commands\', 10\n        )\n\n        self.create_timer(self.dt, self.control_loop)\n\n    def joint_state_callback(self, msg):\n        """Update current joint positions and velocities"""\n        self.current_positions = np.array(msg.position)\n        self.current_velocities = np.array(msg.velocity)\n\n    def target_callback(self, msg):\n        """Update target joint positions"""\n        self.target_positions = np.array(msg.data)\n\n    def control_loop(self):\n        """PID control loop at 100 Hz"""\n        # Compute error\n        error = self.target_positions - self.current_positions\n\n        # Integral term (with anti-windup)\n        self.error_integral += error * self.dt\n        self.error_integral = np.clip(self.error_integral, -1.0, 1.0)\n\n        # Derivative term (use velocity feedback to avoid noise amplification)\n        error_derivative = -self.current_velocities  # de/dt \u2248 -v\n\n        # PID output\n        u = (\n            self.kp * error +\n            self.ki * self.error_integral +\n            self.kd * error_derivative\n        )\n\n        # Publish commands\n        cmd = Float64MultiArray()\n        cmd.data = u.tolist()\n        self.cmd_pub.publish(cmd)\n\ndef main():\n    rclpy.init()\n    node = HumanoidPIDController()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h3,{id:"tuning-pid-gains",children:"Tuning PID Gains"}),"\n",(0,s.jsxs)(e.p,{children:["Use the ",(0,s.jsx)(e.strong,{children:"Ziegler-Nichols method"})," for initial tuning:"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Set K_i = 0, K_d = 0"}),"\n",(0,s.jsx)(e.li,{children:"Increase K_p until the system oscillates with constant amplitude (critical gain K_u)"}),"\n",(0,s.jsx)(e.li,{children:"Measure oscillation period T_u"}),"\n",(0,s.jsxs)(e.li,{children:["Set gains:","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"K_p = 0.6 * K_u"}),"\n",(0,s.jsx)(e.li,{children:"K_i = 1.2 * K_u / T_u"}),"\n",(0,s.jsx)(e.li,{children:"K_d = 0.075 * K_u * T_u"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Practical tips"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High K_p"}),": Fast response but prone to oscillations and overshoot"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High K_i"}),": Eliminates steady-state error but can cause instability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High K_d"}),": Dampens oscillations but amplifies sensor noise"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"For humanoids, start with conservative gains and increase gradually while testing on the real robot."}),"\n",(0,s.jsx)(e.h2,{id:"moveit-integration-for-motion-planning",children:"MoveIt Integration for Motion Planning"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"MoveIt"}),' is the standard motion planning framework for ROS 2, providing inverse kinematics (IK), collision checking, and trajectory generation. For humanoids, MoveIt enables high-level task-space control ("move hand to position X") that automatically computes joint trajectories.']}),"\n",(0,s.jsx)(e.h3,{id:"planning-groups",children:"Planning Groups"}),"\n",(0,s.jsxs)(e.p,{children:["Define planning groups for different body parts in ",(0,s.jsx)(e.code,{children:"moveit_config/srdf"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- File: config/humanoid.srdf --\x3e\n<robot name="humanoid">\n  \x3c!-- Right arm group (7 DOF) --\x3e\n  <group name="right_arm">\n    <joint name="r_shoulder_pitch" />\n    <joint name="r_shoulder_roll" />\n    <joint name="r_shoulder_yaw" />\n    <joint name="r_elbow" />\n    <joint name="r_wrist_pitch" />\n    <joint name="r_wrist_roll" />\n    <joint name="r_wrist_yaw" />\n  </group>\n\n  \x3c!-- Left arm group --\x3e\n  <group name="left_arm">\n    <joint name="l_shoulder_pitch" />\n    \x3c!-- ... --\x3e\n  </group>\n\n  \x3c!-- Upper body (arms + torso) --\x3e\n  <group name="upper_body">\n    <joint name="torso_yaw" />\n    <joint name="torso_pitch" />\n    <group name="right_arm" />\n    <group name="left_arm" />\n  </group>\n</robot>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"inverse-kinematics-solvers",children:"Inverse Kinematics Solvers"}),"\n",(0,s.jsx)(e.p,{children:"MoveIt supports multiple IK solvers:"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Solver"}),(0,s.jsx)(e.th,{children:"Speed"}),(0,s.jsx)(e.th,{children:"Accuracy"}),(0,s.jsx)(e.th,{children:"Notes"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"KDL"}),(0,s.jsx)(e.td,{children:"Fast"}),(0,s.jsx)(e.td,{children:"Good"}),(0,s.jsx)(e.td,{children:"Closed-form, good for 6-7 DOF"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"TRAC-IK"}),(0,s.jsx)(e.td,{children:"Medium"}),(0,s.jsx)(e.td,{children:"Excellent"}),(0,s.jsx)(e.td,{children:"Optimization-based, handles redundancy"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"BioIK"}),(0,s.jsx)(e.td,{children:"Slow"}),(0,s.jsx)(e.td,{children:"Excellent"}),(0,s.jsx)(e.td,{children:"Handles complex constraints"})]})]})]}),"\n",(0,s.jsxs)(e.p,{children:["For humanoids with redundant arms (7+ DOF), use ",(0,s.jsx)(e.strong,{children:"TRAC-IK"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# File: config/kinematics.yaml\n\nright_arm:\n  kinematics_solver: trac_ik_kinematics_plugin/TRAC_IKKinematicsPlugin\n  kinematics_solver_search_resolution: 0.005\n  kinematics_solver_timeout: 0.05\n"})}),"\n",(0,s.jsx)(e.h3,{id:"planning-and-executing-trajectories",children:"Planning and Executing Trajectories"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom moveit.planning import MoveItPy\nfrom moveit.core.robot_state import RobotState\nfrom geometry_msgs.msg import PoseStamped\n\nclass HumanoidMotionPlanner(Node):\n    """High-level motion planning with MoveIt"""\n\n    def __init__(self):\n        super().__init__(\'humanoid_motion_planner\')\n\n        # Initialize MoveItPy\n        self.moveit = MoveItPy(node_name="moveit_py")\n        self.right_arm = self.moveit.get_planning_component("right_arm")\n\n    def plan_to_pose(self, target_pose):\n        """\n        Plan arm motion to target end-effector pose\n\n        Args:\n            target_pose: PoseStamped (position + orientation)\n\n        Returns:\n            Planned trajectory (RobotTrajectory)\n        """\n        # Set pose goal\n        self.right_arm.set_goal_state(\n            pose_stamped_msg=target_pose,\n            pose_link="r_gripper_link"\n        )\n\n        # Plan\n        plan_result = self.right_arm.plan()\n\n        if plan_result.error_code.val != 1:\n            self.get_logger().error(f\'Planning failed: {plan_result.error_code}\')\n            return None\n\n        self.get_logger().info(\'Planning succeeded\')\n        return plan_result.trajectory\n\n    def execute_trajectory(self, trajectory):\n        """Execute planned trajectory on real robot"""\n        # Execute blocking (waits for completion)\n        result = self.right_arm.execute(trajectory, blocking=True)\n\n        if result.error_code.val == 1:\n            self.get_logger().info(\'Execution succeeded\')\n        else:\n            self.get_logger().error(f\'Execution failed: {result.error_code}\')\n\n        return result.error_code.val == 1\n\n    def reach_and_grasp(self, object_pose):\n        """High-level task: reach to object and grasp"""\n        # Approach pose (10cm above object)\n        approach_pose = object_pose\n        approach_pose.pose.position.z += 0.1\n\n        # Plan and execute approach\n        traj_approach = self.plan_to_pose(approach_pose)\n        if traj_approach is None:\n            return False\n\n        self.execute_trajectory(traj_approach)\n\n        # Plan and execute grasp (move down to object)\n        traj_grasp = self.plan_to_pose(object_pose)\n        if traj_grasp is None:\n            return False\n\n        self.execute_trajectory(traj_grasp)\n\n        self.get_logger().info(\'Grasp complete\')\n        return True\n\ndef main():\n    rclpy.init()\n    node = HumanoidMotionPlanner()\n\n    # Example: reach to target pose\n    target = PoseStamped()\n    target.header.frame_id = "base_link"\n    target.pose.position.x = 0.5\n    target.pose.position.y = 0.3\n    target.pose.position.z = 1.0\n    target.pose.orientation.w = 1.0\n\n    node.reach_and_grasp(target)\n\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,s.jsxs)(e.p,{children:["For tasks requiring coordination across multiple limbs (e.g., waving while maintaining balance), we need ",(0,s.jsx)(e.strong,{children:"whole-body control"})," that considers:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance constraints"}),": Keep center of mass (COM) above support polygon"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint limits"}),": Respect maximum/minimum joint angles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision avoidance"}),": Prevent self-collision between limbs"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"task-space-vs-joint-space-control",children:"Task-Space vs Joint-Space Control"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Joint-space control"}),": Command joint angles directly"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Joint-space: specify exact joint configuration\ntarget_joints = [0.1, 0.2, -0.5, 1.0, ...]  # radians\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task-space control"}),": Command end-effector pose, solve for joints via IK"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Task-space: specify desired hand position\ntarget_pose = PoseStamped()\ntarget_pose.pose.position = (0.5, 0.3, 1.0)\n# MoveIt computes joint angles automatically\n"})}),"\n",(0,s.jsx)(e.p,{children:'Task-space is preferred for manipulation (easier to specify "grab object at X") while joint-space is used for whole-body poses (e.g., predefined gestures).'}),"\n",(0,s.jsx)(e.h3,{id:"coordinated-arm--torso-motion",children:"Coordinated Arm + Torso Motion"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def plan_coordinated_reach(self, target_pose):\n    """\n    Plan reach using arm + torso for extended workspace\n\n    Uses upper_body planning group (includes torso joints)\n    """\n    upper_body = self.moveit.get_planning_component("upper_body")\n\n    # Set pose goal for right hand\n    upper_body.set_goal_state(\n        pose_stamped_msg=target_pose,\n        pose_link="r_gripper_link"\n    )\n\n    # Add balance constraint (keep COM over feet)\n    constraints = Constraints()\n    constraints.name = "balance"\n\n    position_constraint = PositionConstraint()\n    position_constraint.link_name = "base_link"\n    position_constraint.target_point_offset.z = 0.0  # COM height\n    # ... define constraint region\n\n    upper_body.set_path_constraints(constraints)\n\n    # Plan (MoveIt automatically uses torso for extended reach)\n    plan_result = upper_body.plan()\n\n    return plan_result.trajectory\n'})}),"\n",(0,s.jsx)(e.h2,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,s.jsx)(e.h3,{id:"issue-1-joint-limit-violations",children:"Issue 1: Joint Limit Violations"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Problem"}),": Commanded joint positions exceed URDF-defined limits, causing hardware errors."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Solution"}),": Implement software joint limit checking:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def enforce_joint_limits(self, joint_positions):\n    """Clamp joint positions to safe limits"""\n    joint_limits_lower = np.array([-3.14, -1.57, -3.14, ...])  # radians\n    joint_limits_upper = np.array([3.14, 1.57, 3.14, ...])\n\n    return np.clip(joint_positions, joint_limits_lower, joint_limits_upper)\n'})}),"\n",(0,s.jsx)(e.p,{children:"Add a safety margin (e.g., 5\xb0) to avoid mechanical hard stops."}),"\n",(0,s.jsx)(e.h3,{id:"issue-2-self-collision",children:"Issue 2: Self-Collision"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Problem"}),": During whole-body motions, limbs collide with each other or the torso."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Solution"}),": Enable MoveIt collision checking:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# In SRDF, define collision pairs to disable (for adjacent links)\n<disable_collisions link1="r_shoulder" link2="r_upper_arm" reason="Adjacent" />\n\n# In planning, MoveIt automatically avoids all other collisions\nplan_result = arm.plan()  # Collision-free by default\n'})}),"\n",(0,s.jsx)(e.h3,{id:"issue-3-kinematic-singularities",children:"Issue 3: Kinematic Singularities"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Problem"}),": IK solver fails near singularities (e.g., fully extended arm)."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Solution"}),": Add redundant DOF (7-DOF arm instead of 6) or constraint elbow position:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# Constraint to keep elbow bent (avoid singularity)\njoint_constraint = JointConstraint()\njoint_constraint.joint_name = "r_elbow"\njoint_constraint.position = 1.57  # 90\xb0 bent\njoint_constraint.tolerance_above = 1.0\njoint_constraint.tolerance_below = 0.5\njoint_constraint.weight = 0.5\n\nconstraints.joint_constraints.append(joint_constraint)\n'})}),"\n",(0,s.jsx)(e.h3,{id:"issue-4-oscillations-and-instability",children:"Issue 4: Oscillations and Instability"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Problem"}),": High PID gains cause joints to oscillate around target."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Solution"}),": Reduce K_d or add low-pass filtering to derivative term:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Exponential moving average for derivative\nself.error_derivative_filtered = (\n    0.9 * self.error_derivative_filtered +\n    0.1 * error_derivative\n)\n\nu_d = self.kd * self.error_derivative_filtered\n"})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Start with simulation"}),": Test control gains in Gazebo before real hardware"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monitor joint torques"}),": Detect overloads before hardware damage"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Implement safety limits"}),": Software e-stops for unexpected motions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use feedforward control"}),": Compensate for gravity/inertia (advanced)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Log control data"}),": Record errors, commands, and states for tuning"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"Key takeaways from this chapter:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"PID control"})," provides stable joint-level tracking for humanoid robots when properly tuned (Kp ~100, Ki ~0.1, Kd ~10)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"MoveIt"})," enables high-level task-space control with automatic IK, collision checking, and trajectory generation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Whole-body coordination"})," requires balancing multiple objectives (task goals, balance, joint limits, collisions)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Common pitfalls"})," (joint limits, singularities, oscillations) have well-established solutions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tuning"})," is iterative: start conservative in simulation, refine on real hardware"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"These techniques form the foundation for humanoid manipulation and will be extended in the next chapter for grasping tasks."}),"\n",(0,s.jsx)(e.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"What are the roles of the P, I, and D terms in a PID controller? How does each affect system response?"}),"\n",(0,s.jsx)(e.li,{children:"Why is TRAC-IK preferred over KDL for redundant humanoid arms?"}),"\n",(0,s.jsx)(e.li,{children:"Explain the difference between task-space and joint-space control. When would you use each?"}),"\n",(0,s.jsx)(e.li,{children:"How does MoveIt handle collision avoidance during motion planning?"}),"\n",(0,s.jsx)(e.li,{children:"What causes kinematic singularities, and how can they be avoided?"}),"\n",(0,s.jsx)(e.li,{children:"Describe a scenario where whole-body control (arm + torso) is necessary."}),"\n",(0,s.jsx)(e.li,{children:"How would you debug a humanoid arm that oscillates when reaching to a target?"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"hands-on-exercises",children:"Hands-On Exercises"}),"\n",(0,s.jsx)(e.h3,{id:"exercise-1-pid-tuning",children:"Exercise 1: PID Tuning"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Objective"}),": Tune PID gains for a simulated humanoid arm joint."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Spawn humanoid in Gazebo"}),"\n",(0,s.jsx)(e.li,{children:"Implement PID controller for shoulder pitch joint"}),"\n",(0,s.jsx)(e.li,{children:"Use Ziegler-Nichols method to find initial gains"}),"\n",(0,s.jsx)(e.li,{children:"Test step response (plot position vs time)"}),"\n",(0,s.jsx)(e.li,{children:"Iteratively tune to achieve <5% overshoot, <1s settling time"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected Outcome"}),": Smooth, responsive joint tracking without oscillations."]}),"\n",(0,s.jsx)(e.h3,{id:"exercise-2-moveit-motion-planning",children:"Exercise 2: MoveIt Motion Planning"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Objective"}),": Use MoveIt to plan collision-free arm motions."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Configure MoveIt for your humanoid URDF"}),"\n",(0,s.jsx)(e.li,{children:"Define right_arm planning group"}),"\n",(0,s.jsx)(e.li,{children:"Implement plan_to_pose function"}),"\n",(0,s.jsx)(e.li,{children:"Command arm to reach multiple target poses"}),"\n",(0,s.jsx)(e.li,{children:"Visualize planned trajectories in RViz"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected Outcome"}),": Collision-free reaching motions to all target poses."]}),"\n",(0,s.jsx)(e.h3,{id:"exercise-3-whole-body-waving",children:"Exercise 3: Whole-Body Waving"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Objective"}),": Implement a waving gesture using arm + torso coordination."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Define upper_body planning group (arm + torso)"}),"\n",(0,s.jsx)(e.li,{children:"Plan a waving motion (hand moves side-to-side)"}),"\n",(0,s.jsx)(e.li,{children:"Add balance constraint to keep COM over feet"}),"\n",(0,s.jsx)(e.li,{children:"Execute on simulated humanoid"}),"\n",(0,s.jsx)(e.li,{children:"Verify torso compensates for arm motion"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected Outcome"}),": Smooth waving gesture without tipping over."]}),"\n",(0,s.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Modern Robotics"})," (Lynch & Park): Chapter 11 on robot control"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"MoveIt Documentation"}),": ",(0,s.jsx)(e.a,{href:"https://moveit.picknik.ai/",children:"https://moveit.picknik.ai/"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"TRAC-IK Paper"}),': "TRAC-IK: An Open-Source Library for Improved Solving of Generic Inverse Kinematics" (2015)']}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"PID Control Tutorial"}),": ",(0,s.jsx)(e.a,{href:"https://www.ni.com/en-us/innovations/white-papers/06/pid-theory-explained.html",children:"https://www.ni.com/en-us/innovations/white-papers/06/pid-theory-explained.html"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS 2 Control"}),": ",(0,s.jsx)(e.a,{href:"https://control.ros.org/",children:"https://control.ros.org/"})]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Previous"}),": ",(0,s.jsx)(e.a,{href:"/AI_COURSE_book/docs/module-04-vla/week-11/ch17-humanoid-urdf",children:"Chapter 17 - Humanoid Robot URDF and Kinematics"}),"\n",(0,s.jsx)(e.strong,{children:"Next"}),": ",(0,s.jsx)(e.a,{href:"/AI_COURSE_book/docs/module-04-vla/week-12/ch19-grasping",children:"Chapter 19 - Robotic Grasping with Modern Approaches"})]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>l});var o=i(6540);const s={},t=o.createContext(s);function r(n){const e=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),o.createElement(t.Provider,{value:e},n.children)}}}]);