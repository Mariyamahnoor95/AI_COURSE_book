"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6573],{3174:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-02-digital-twin/week-06/ch07-gazebo-physics","title":"Gazebo Physics Simulation","description":"Learning Objectives","source":"@site/docs/module-02-digital-twin/week-06/ch07-gazebo-physics.md","sourceDirName":"module-02-digital-twin/week-06","slug":"/module-02-digital-twin/week-06/ch07-gazebo-physics","permalink":"/AI_COURSE_book/docs/module-02-digital-twin/week-06/ch07-gazebo-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-02-digital-twin/week-06/ch07-gazebo-physics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"ch07-gazebo-physics","title":"Gazebo Physics Simulation","sidebar_label":"Gazebo Physics","sidebar_position":1},"sidebar":"textbookSidebar","previous":{"title":"Module 2: Digital Twin (Weeks 6-7)","permalink":"/AI_COURSE_book/docs/module-02-digital-twin"},"next":{"title":"Sensor Modeling in Simulation","permalink":"/AI_COURSE_book/docs/module-02-digital-twin/week-06/ch08-sensor-modeling"}}');var r=s(4848),l=s(8453);const t={id:"ch07-gazebo-physics",title:"Gazebo Physics Simulation",sidebar_label:"Gazebo Physics",sidebar_position:1},o="Gazebo Physics Simulation",a={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. What is Gazebo?",id:"1-what-is-gazebo",level:2},{value:"Overview",id:"overview",level:3},{value:"Physics Engines",id:"physics-engines",level:3},{value:"Simulated Sensors",id:"simulated-sensors",level:3},{value:"2. Installing and Launching Gazebo",id:"2-installing-and-launching-gazebo",level:2},{value:"Installation (Ubuntu 22.04 + ROS 2 Humble)",id:"installation-ubuntu-2204--ros-2-humble",level:3},{value:"Launching Gazebo",id:"launching-gazebo",level:3},{value:"Gazebo Interface",id:"gazebo-interface",level:3},{value:"3. Spawning and Controlling Robots",id:"3-spawning-and-controlling-robots",level:2},{value:"Spawning a Robot",id:"spawning-a-robot",level:3},{value:"Controlling the Robot",id:"controlling-the-robot",level:3},{value:"Reading Sensor Data",id:"reading-sensor-data",level:3},{value:"4. Physics Configuration",id:"4-physics-configuration",level:2},{value:"World Configuration",id:"world-configuration",level:3},{value:"Physics Parameters",id:"physics-parameters",level:3},{value:"5. Digital Twin Workflow",id:"5-digital-twin-workflow",level:2},{value:"Development Pipeline",id:"development-pipeline",level:3},{value:"Sim-to-Real Transfer",id:"sim-to-real-transfer",level:3},{value:"6. Practical Example: Square Pattern Controller",id:"6-practical-example-square-pattern-controller",level:2},{value:"7. Best Practices",id:"7-best-practices",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Debugging Tips",id:"debugging-tips",level:3},{value:"Common Issues",id:"common-issues",level:3},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2},{value:"Hands-on Exercises",id:"hands-on-exercises",level:2},{value:"Exercise 1: Modify the Square",id:"exercise-1-modify-the-square",level:3},{value:"Exercise 2: Sensor Exploration",id:"exercise-2-sensor-exploration",level:3},{value:"Exercise 3: Custom World",id:"exercise-3-custom-world",level:3},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"gazebo-physics-simulation",children:"Gazebo Physics Simulation"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand what Gazebo is and why physics simulation matters for robotics"}),"\n",(0,r.jsx)(n.li,{children:"Launch and navigate the Gazebo simulation environment"}),"\n",(0,r.jsx)(n.li,{children:"Spawn robots and objects in simulation"}),"\n",(0,r.jsx)(n.li,{children:"Understand physics engines (ODE, Bullet, Simbody)"}),"\n",(0,r.jsx)(n.li,{children:"Control simulated robots using ROS 2"}),"\n",(0,r.jsx)(n.li,{children:"Recognize the sim-to-real gap and mitigation strategies"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["Before deploying a robot in the real world, we need to test our algorithms safely and repeatedly. ",(0,r.jsx)(n.strong,{children:"Gazebo"})," is an open-source 3D robot simulator that provides realistic physics, high-quality graphics, and seamless ROS 2 integration."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why simulate?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Safety"}),": Test dangerous scenarios (falling, collisions) without hardware damage"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Speed"}),": Iterate algorithms 10-100x faster than real-time"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Cost"}),": Avoid expensive hardware for initial development"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Reproducibility"}),": Same initial conditions every time"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Scalability"}),": Test with thousands of robots or environments"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Impossible scenarios"}),": Perfect sensors, instant teleportation for testing"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The digital twin concept"}),": Gazebo creates a virtual replica of your physical robot where you can:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Develop and test control algorithms"}),"\n",(0,r.jsx)(n.li,{children:"Train machine learning models"}),"\n",(0,r.jsx)(n.li,{children:"Validate sensor processing pipelines"}),"\n",(0,r.jsx)(n.li,{children:"Debug multi-robot coordination"}),"\n",(0,r.jsx)(n.li,{children:"Generate synthetic training data"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This chapter introduces Gazebo and demonstrates how to use it for Physical AI development."}),"\n",(0,r.jsx)(n.h2,{id:"1-what-is-gazebo",children:"1. What is Gazebo?"}),"\n",(0,r.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["Gazebo (also called Gazebo Classic or Gazebo 11) is a standalone simulator that works with ROS 2 through the ",(0,r.jsx)(n.code,{children:"gazebo_ros"})," packages. The newer ",(0,r.jsx)(n.strong,{children:"Gazebo"})," (formerly Ignition Gazebo) is a complete rewrite with improved architecture."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Core components:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics engine"}),": Simulates gravity, collisions, friction, forces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rendering engine"}),": OGRE-based 3D graphics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor simulation"}),": Camera, LiDAR, IMU, GPS, depth sensors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugin system"}),": Extend functionality with custom code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 integration"}),": Publish/subscribe to ROS topics from simulation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo supports multiple physics backends:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Engine"}),(0,r.jsx)(n.th,{children:"Speed"}),(0,r.jsx)(n.th,{children:"Accuracy"}),(0,r.jsx)(n.th,{children:"Best For"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"ODE"})}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Moderate"}),(0,r.jsx)(n.td,{children:"Mobile robots, prototyping"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Bullet"})}),(0,r.jsx)(n.td,{children:"Fastest"}),(0,r.jsx)(n.td,{children:"Lower"}),(0,r.jsx)(n.td,{children:"Real-time, many objects"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Simbody"})}),(0,r.jsx)(n.td,{children:"Slowest"}),(0,r.jsx)(n.td,{children:"Highest"}),(0,r.jsx)(n.td,{children:"Precise manipulation, biomechanics"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"DART"})}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Humanoids, complex dynamics"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default"}),": ODE (Open Dynamics Engine) balances speed and accuracy for most robotics applications."]}),"\n",(0,r.jsx)(n.h3,{id:"simulated-sensors",children:"Simulated Sensors"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo can simulate various sensors:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cameras"}),": RGB, depth, stereo"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LiDAR"}),": 2D and 3D laser scanners"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IMU"}),": Accelerometer, gyroscope, magnetometer (with noise)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GPS"}),": Global positioning (configurable accuracy)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Contact"}),": Collision detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Force/torque"}),": Joint effort sensing"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sensor noise"}),": Add Gaussian noise to simulate real sensor imperfections:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<sensor name="imu" type="imu">\n  <noise>\n    <type>gaussian</type>\n    <rate>\n      <mean>0.0</mean>\n      <stddev>0.001</stddev>\n    </rate>\n  </noise>\n</sensor>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"2-installing-and-launching-gazebo",children:"2. Installing and Launching Gazebo"}),"\n",(0,r.jsx)(n.h3,{id:"installation-ubuntu-2204--ros-2-humble",children:"Installation (Ubuntu 22.04 + ROS 2 Humble)"}),"\n",(0,r.jsxs)(n.p,{children:["Gazebo is included with ",(0,r.jsx)(n.code,{children:"ros-humble-desktop"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Install if not already present\nsudo apt update\nsudo apt install ros-humble-gazebo-ros-pkgs\n\n# Verify installation\ngazebo --version\n"})}),"\n",(0,r.jsx)(n.h3,{id:"launching-gazebo",children:"Launching Gazebo"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Method 1: Standalone Gazebo"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gazebo\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Method 2: With ROS 2"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 launch gazebo_ros gazebo.launch.py\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Method 3: With a world file"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gazebo /usr/share/gazebo-11/worlds/cafe.world\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Method 4: Empty world (fastest)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 launch gazebo_ros empty_world.launch.py\n"})}),"\n",(0,r.jsx)(n.h3,{id:"gazebo-interface",children:"Gazebo Interface"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Main panels:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scene"}),": 3D view of the simulated world"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Insert"}),": Add models from library"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"World"}),": Configure lighting, physics, atmosphere"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Models"}),": List of spawned objects"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time"}),": Real-time vs sim-time, play/pause controls"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Camera controls:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Left-click + drag"}),": Rotate view"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scroll"}),": Zoom in/out"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Middle-click + drag"}),": Pan view"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shift + left-click"}),": Rotate around object"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-spawning-and-controlling-robots",children:"3. Spawning and Controlling Robots"}),"\n",(0,r.jsx)(n.h3,{id:"spawning-a-robot",children:"Spawning a Robot"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Using TurtleBot3 (popular mobile robot):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Set model type (burger, waffle, waffle_pi)\nexport TURTLEBOT3_MODEL=burger\n\n# Launch world with robot\nros2 launch turtlebot3_gazebo turtlebot3_world.launch.py\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Programmatic spawning:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom gazebo_msgs.srv import SpawnEntity\n\ndef spawn_robot():\n    \"\"\"Spawn a robot model in Gazebo\"\"\"\n    rclpy.init()\n    node = rclpy.create_node('robot_spawner')\n\n    # Create service client\n    client = node.create_client(SpawnEntity, '/spawn_entity')\n    client.wait_for_service()\n\n    # Read robot description (URDF/SDF)\n    with open('my_robot.urdf', 'r') as f:\n        robot_xml = f.read()\n\n    # Create request\n    request = SpawnEntity.Request()\n    request.name = 'my_robot'\n    request.xml = robot_xml\n    request.robot_namespace = 'robot1'\n    request.initial_pose.position.x = 0.0\n    request.initial_pose.position.y = 0.0\n    request.initial_pose.position.z = 0.5\n\n    # Spawn robot\n    future = client.call_async(request)\n    rclpy.spin_until_future_complete(node, future)\n\n    if future.result().success:\n        node.get_logger().info('Robot spawned successfully!')\n    else:\n        node.get_logger().error(f'Failed: {future.result().status_message}')\n\n    node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"controlling-the-robot",children:"Controlling the Robot"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Velocity control (differential drive robot):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\n\nclass SimpleController(Node):\n    def __init__(self):\n        super().__init__(\'simple_controller\')\n        self.publisher = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.timer = self.create_timer(0.1, self.control_loop)\n\n    def control_loop(self):\n        """Send velocity commands to robot"""\n        msg = Twist()\n\n        # Drive forward at 0.2 m/s\n        msg.linear.x = 0.2\n\n        # Turn slightly left\n        msg.angular.z = 0.1\n\n        self.publisher.publish(msg)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"See complete example"}),": ",(0,r.jsx)(n.code,{children:"/static/code/digital-twin/chapter07/simple_robot_controller.py"})]}),"\n",(0,r.jsx)(n.h3,{id:"reading-sensor-data",children:"Reading Sensor Data"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"LiDAR data:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from sensor_msgs.msg import LaserScan\n\nclass SensorReader(Node):\n    def __init__(self):\n        super().__init__('sensor_reader')\n        self.sub = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.scan_callback,\n            10\n        )\n\n    def scan_callback(self, msg):\n        \"\"\"Process laser scan data\"\"\"\n        # Get minimum distance\n        min_dist = min(msg.ranges)\n\n        # Get distance directly ahead\n        front_idx = len(msg.ranges) // 2\n        front_dist = msg.ranges[front_idx]\n\n        self.get_logger().info(\n            f'Min: {min_dist:.2f}m, Front: {front_dist:.2f}m'\n        )\n"})}),"\n",(0,r.jsx)(n.h2,{id:"4-physics-configuration",children:"4. Physics Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"world-configuration",children:"World Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Create a custom world file (",(0,r.jsx)(n.code,{children:"my_world.world"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <world name="default">\n    \x3c!-- Physics settings --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n\n      <gravity>0 0 -9.81</gravity>\n\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>50</iters>\n        </solver>\n      </ode>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Add obstacles --\x3e\n    <include>\n      <uri>model://cafe_table</uri>\n      <pose>2 0 0 0 0 0</pose>\n    </include>\n\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"physics-parameters",children:"Physics Parameters"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"max_step_size"}),": Simulation time step (smaller = more accurate, slower)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"real_time_factor"}),": Target speed (1.0 = real-time, 0.5 = half-speed)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"gravity"}),": Gravitational acceleration (default: -9.81 m/s\xb2)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"solver iterations"}),": Higher = more stable contacts, slower"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Tuning for performance:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Fast but less accurate --\x3e\n<max_step_size>0.01</max_step_size>\n<real_time_update_rate>100</real_time_update_rate>\n<iters>20</iters>\n\n\x3c!-- Slow but very accurate --\x3e\n<max_step_size>0.0001</max_step_size>\n<real_time_update_rate>10000</real_time_update_rate>\n<iters>100</iters>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"5-digital-twin-workflow",children:"5. Digital Twin Workflow"}),"\n",(0,r.jsx)(n.h3,{id:"development-pipeline",children:"Development Pipeline"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. Design robot (URDF/SDF)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Define links (rigid bodies)"}),"\n",(0,r.jsx)(n.li,{children:"Define joints (connections)"}),"\n",(0,r.jsx)(n.li,{children:"Add sensors and actuators"}),"\n",(0,r.jsx)(n.li,{children:"Specify mass, inertia, collision geometry"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. Test in Gazebo"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spawn robot in simulated world"}),"\n",(0,r.jsx)(n.li,{children:"Verify kinematics and dynamics"}),"\n",(0,r.jsx)(n.li,{children:"Tune controller parameters"}),"\n",(0,r.jsx)(n.li,{children:"Test edge cases (falling, collisions)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"3. Transfer to hardware"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Same ROS 2 nodes work on real robot"}),"\n",(0,r.jsx)(n.li,{children:"Adjust for hardware differences"}),"\n",(0,r.jsx)(n.li,{children:"Fine-tune parameters based on real-world tests"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"4. Iterate"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Update simulation based on real-world observations"}),"\n",(0,r.jsx)(n.li,{children:"Improve physics parameters"}),"\n",(0,r.jsx)(n.li,{children:"Add noise to sensors"}),"\n",(0,r.jsx)(n.li,{children:"Refine controller"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sim-to-real-transfer",children:"Sim-to-Real Transfer"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The gap"}),": Simulation is imperfect. Real robots experience:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sensor noise and delays"}),"\n",(0,r.jsx)(n.li,{children:"Actuator lag and backlash"}),"\n",(0,r.jsx)(n.li,{children:"Unmodeled friction and compliance"}),"\n",(0,r.jsx)(n.li,{children:"Environmental variations (lighting, surface, temperature)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Bridging strategies:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Domain randomization"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Randomize physics parameters during training"}),"\n",(0,r.jsx)(n.li,{children:"Vary sensor noise, friction, mass"}),"\n",(0,r.jsx)(n.li,{children:"Train robust policies that work despite uncertainty"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"System identification"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Measure real robot parameters precisely"}),"\n",(0,r.jsx)(n.li,{children:"Update simulation to match reality"}),"\n",(0,r.jsx)(n.li,{children:"Iteratively refine model"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Sim-to-real adaptation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fine-tune in simulation"}),"\n",(0,r.jsx)(n.li,{children:"Quick adaptation on real hardware"}),"\n",(0,r.jsx)(n.li,{children:"Use reality gap as a feature (domain adaptation)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Hardware-in-the-loop"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Connect real sensors to simulation"}),"\n",(0,r.jsx)(n.li,{children:"Test sensor processing with simulated actuators"}),"\n",(0,r.jsx)(n.li,{children:"Gradual transition from sim to real"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"6-practical-example-square-pattern-controller",children:"6. Practical Example: Square Pattern Controller"}),"\n",(0,r.jsx)(n.p,{children:"This example demonstrates a robot driving in a 2m \xd7 2m square using odometry feedback."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry\nimport math\n\nclass SquarePatternController(Node):\n    """Drive robot in square pattern using state machine"""\n\n    STATE_FORWARD = 0\n    STATE_TURN = 1\n\n    def __init__(self):\n        super().__init__(\'square_controller\')\n\n        # Publishers and subscribers\n        self.cmd_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.odom_sub = self.create_subscription(\n            Odometry, \'/odom\', self.odom_callback, 10\n        )\n\n        # Parameters\n        self.side_length = 2.0  # meters\n        self.linear_speed = 0.2  # m/s\n        self.angular_speed = 0.5  # rad/s\n\n        # State\n        self.state = self.STATE_FORWARD\n        self.start_x = 0.0\n        self.start_y = 0.0\n        self.start_theta = 0.0\n        self.current_x = 0.0\n        self.current_y = 0.0\n        self.current_theta = 0.0\n        self.sides_completed = 0\n\n        # Control loop\n        self.timer = self.create_timer(0.1, self.control_loop)\n\n    def odom_callback(self, msg):\n        """Update position from odometry"""\n        self.current_x = msg.pose.pose.position.x\n        self.current_y = msg.pose.pose.position.y\n\n        # Convert quaternion to yaw\n        q = msg.pose.pose.orientation\n        siny_cosp = 2 * (q.w * q.z + q.x * q.y)\n        cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)\n        self.current_theta = math.atan2(siny_cosp, cosy_cosp)\n\n    def control_loop(self):\n        """State machine for square pattern"""\n        twist = Twist()\n\n        if self.state == self.STATE_FORWARD:\n            # Calculate distance traveled\n            distance = math.sqrt(\n                (self.current_x - self.start_x) ** 2 +\n                (self.current_y - self.start_y) ** 2\n            )\n\n            if distance < self.side_length:\n                # Keep moving forward\n                twist.linear.x = self.linear_speed\n            else:\n                # Switch to turning\n                self.state = self.STATE_TURN\n                self.start_theta = self.current_theta\n                self.sides_completed += 1\n                self.get_logger().info(f\'Side {self.sides_completed}/4 complete\')\n\n        elif self.state == self.STATE_TURN:\n            # Calculate angle turned\n            angle_turned = abs(self.current_theta - self.start_theta)\n\n            if angle_turned < math.pi / 2 - 0.1:  # 90\xb0 minus tolerance\n                # Keep turning\n                twist.angular.z = self.angular_speed\n            else:\n                # Switch to forward\n                self.state = self.STATE_FORWARD\n                self.start_x = self.current_x\n                self.start_y = self.current_y\n\n                if self.sides_completed >= 4:\n                    self.get_logger().info(\'Square complete!\')\n                    self.cmd_pub.publish(Twist())  # Stop\n                    self.timer.cancel()\n                    return\n\n        self.cmd_pub.publish(twist)\n\ndef main():\n    rclpy.init()\n    controller = SquarePatternController()\n    rclpy.spin(controller)\n    controller.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State machine"}),": Alternates between driving forward and turning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Odometry feedback"}),": Tracks position and orientation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distance calculation"}),": Determines when to switch states"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Angle measurement"}),": Ensures 90\xb0 turns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Completion"}),": Stops after 4 sides"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Run it:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Terminal 1: Launch Gazebo with TurtleBot3\nexport TURTLEBOT3_MODEL=burger\nros2 launch turtlebot3_gazebo empty_world.launch.py\n\n# Terminal 2: Run controller\npython3 simple_robot_controller.py\n"})}),"\n",(0,r.jsx)(n.h2,{id:"7-best-practices",children:"7. Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Simplify collision geometry"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use primitive shapes (boxes, cylinders) instead of meshes"}),"\n",(0,r.jsx)(n.li,{children:"Reduce polygon count for visual meshes"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Disable unused features"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Turn off shadows if not needed"}),"\n",(0,r.jsx)(n.li,{children:"Reduce sensor update rates"}),"\n",(0,r.jsx)(n.li,{children:"Disable GUI rendering when running headless"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Adjust time step"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Larger time step = faster simulation, less accurate"}),"\n",(0,r.jsx)(n.li,{children:"Find balance for your application"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"debugging-tips",children:"Debugging Tips"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Visualize frames"}),": Use RViz to see coordinate frames"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check topics"}),": ",(0,r.jsx)(n.code,{children:"ros2 topic list"})," and ",(0,r.jsx)(n.code,{children:"ros2 topic echo /odom"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor TF"}),": ",(0,r.jsx)(n.code,{children:"ros2 run tf2_tools view_frames"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Log messages"}),": Use ",(0,r.jsx)(n.code,{children:"self.get_logger().info()"})," liberally"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pause simulation"}),": Press space bar to freeze and inspect"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Robot falls through ground:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check collision geometry is present"}),"\n",(0,r.jsx)(n.li,{children:"Ensure mass and inertia are defined"}),"\n",(0,r.jsx)(n.li,{children:"Verify ground plane exists"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Slow simulation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduce physics accuracy (larger time step)"}),"\n",(0,r.jsx)(n.li,{children:"Simplify models"}),"\n",(0,r.jsx)(n.li,{children:"Close GUI panels"}),"\n",(0,r.jsx)(n.li,{children:"Run headless (no graphics)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Unstable motion/vibrations:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Increase solver iterations"}),"\n",(0,r.jsx)(n.li,{children:"Reduce time step"}),"\n",(0,r.jsx)(n.li,{children:"Check joint limits and damping"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"In this chapter, we learned:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo"})," is a physics-based robot simulator for safe, fast iteration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics engines"})," (ODE, Bullet, Simbody) trade off speed vs accuracy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Digital twins"})," mirror physical robots for algorithm development"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sim-to-real gap"})," requires careful modeling and domain randomization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 integration"})," allows same code to work in sim and on real hardware"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State machines"})," enable structured control logic for complex behaviors"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key benefits of simulation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Test dangerous scenarios safely"}),"\n",(0,r.jsx)(n.li,{children:"Iterate algorithms much faster than real-time"}),"\n",(0,r.jsx)(n.li,{children:"Reduce hardware costs during development"}),"\n",(0,r.jsx)(n.li,{children:"Generate synthetic training data at scale"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Remember"}),": Simulation is a tool, not a replacement for real-world testing. Always validate on hardware."]}),"\n",(0,r.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"What is the main advantage of using Gazebo for robotics development?"}),"\n",(0,r.jsx)(n.li,{children:"How do physics engines like ODE and Bullet differ?"}),"\n",(0,r.jsx)(n.li,{children:'What is the "sim-to-real gap" and why does it matter?'}),"\n",(0,r.jsx)(n.li,{children:"Why add sensor noise in simulation?"}),"\n",(0,r.jsx)(n.li,{children:"How does odometry help the square pattern controller?"}),"\n",(0,r.jsx)(n.li,{children:"What would happen if the controller didn't check angle tolerance in turns?"}),"\n",(0,r.jsx)(n.li,{children:"Name three strategies for improving sim-to-real transfer."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hands-on-exercises",children:"Hands-on Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-1-modify-the-square",children:"Exercise 1: Modify the Square"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Change side length to 3 meters"}),"\n",(0,r.jsx)(n.li,{children:"Make the robot drive a triangle instead"}),"\n",(0,r.jsxs)(n.li,{children:["Add obstacle avoidance using ",(0,r.jsx)(n.code,{children:"/scan"})," topic"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-2-sensor-exploration",children:"Exercise 2: Sensor Exploration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Spawn TurtleBot3 in ",(0,r.jsx)(n.code,{children:"turtlebot3_world.launch.py"})]}),"\n",(0,r.jsxs)(n.li,{children:["Subscribe to ",(0,r.jsx)(n.code,{children:"/scan"})," and ",(0,r.jsx)(n.code,{children:"/camera/image_raw"})]}),"\n",(0,r.jsx)(n.li,{children:"Visualize in RViz"}),"\n",(0,r.jsx)(n.li,{children:"Compare sensor data in different environments"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-3-custom-world",children:"Exercise 3: Custom World"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create a world file with walls and obstacles"}),"\n",(0,r.jsx)(n.li,{children:"Spawn a robot and test navigation"}),"\n",(0,r.jsx)(n.li,{children:"Add simulated noise to sensors"}),"\n",(0,r.jsx)(n.li,{children:"Compare noisy vs ideal sensor behavior"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"http://classic.gazebosim.org/",children:"Gazebo Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Advanced/Simulators/Gazebo/Gazebo.html",children:"ROS 2 + Gazebo Integration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://emanual.robotis.com/docs/en/platform/turtlebot3/simulation/",children:"TurtleBot3 Simulation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.sciencedirect.com/science/article/pii/S0736584520301314",children:"Digital Twin Concepts"})}),"\n",(0,r.jsxs)(n.li,{children:["Code example: ",(0,r.jsx)(n.code,{children:"/static/code/digital-twin/chapter07/"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next Chapter"}),": ",(0,r.jsx)(n.a,{href:"/AI_COURSE_book/docs/module-02-digital-twin/week-06/ch08-sensor-modeling",children:"Sensor Modeling in Simulation \u2192"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Previous Chapter"}),": ",(0,r.jsx)(n.a,{href:"/AI_COURSE_book/docs/module-01-ros2/week-05/ch06-nav2-basics",children:"\u2190 ROS 2 Nav2 Basics"})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var i=s(6540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);